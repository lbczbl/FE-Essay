

## 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

装箱：就是把基本类型转变为对应的对象，装箱分为隐式和显式

```javascript
//隐式装箱：每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象
//在这个基本类型上调用方法，其实就是在这个基本类型对象上调用方案
//这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁
let num = 123;
num.toFixed(2);   //'123.00' //上方代码在后台的真正步骤为
var c = new Number(123)
c.toFixed(2)
c = null
//显式装箱：通过内置对象Boolean、Object、String等可以对基本类型进行显式装箱
var obj = new String('123')
```

拆箱：拆箱与装箱相反，把对象转变为基本类型的值

```javascript
Number([1]); //1
//转换演变
[1].valueOf()  //[1]
[1].toString()  // '1'
Number('1')   //1
```

## 理解值类型和引用类型

变量可以存在两种类型的值，即原始值和引用值

|            | 原始值                                                       | 引用值                                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 概念       | 原始值指的是原始类型的值，也叫基本类型                       | 引用值指的是引用类型的值                                     |
| 数据类型   | Number、String、Boolean、Null、Undefined                     | Object、Function、Array、Date、RegExp                        |
| 存储       | 栈，占内存空间固定，使用后被销毁                             | 堆，占内存空间不固定，使用后不一定被销毁，只有一个对象没有任何引用时，系统的垃圾回收机制才会回收销毁 |
| 赋值方式   | 1.值的拷贝，创建一个新对象    2.保存与复制的是值本身    3.两份数据在内存中是完全独立的 | 1.引用的拷贝，创建一个新引用    2.保存与复制的是指向一个对象的一个指针   3.变量中的存储的地址赋值一份单独存储，两个变量中修改其中一个对象，另外一个引用来访问的时候，也会访问到修改后的值 |
| 值是否可变 | 不可变                                                       | 可变                                                         |
| 作用域     | 函数作用域，在函数内部修改时生效，函数销毁时生效             | 函数中被修改时修改的是运行时数据区中的值，即使函数被销毁，变量的值依旧被改变 |
| 比较方式   | 值的比较                                                     | 引用的比较                                                   |
| 检测类型   | typeof运算符                                                 | instanceof运算符                                             |
|            |                                                              |                                                              |

## 理解原型设计模式以及JavaScript中的原型规则

原型规则

1. 所有的引用类型（对象、数组、函数）都具有对象特性，即可自由扩展属性（除了null以外）

   ```javascript
   var obj = {}
   obj.a = 100
   var arr = []
   arr.a = 100
   function fn() {}
   fn.a = 100
   ```

2. 所有的引用类型（对象、数组、函数），都有一个_proto_属性（隐式原型），属性值是一个普通对象

   ```
   console.log(obj._proto_)
   console.log(arr._proto_)
   console.log(fn._proto_)
   ```

3. 所有的函数，都有一个prototype属性（显式原型），属性值是一个普通对象

   ```
   console.log(fn.prototype)
   ```

4. 所有的引用类型（对象、数组、函数），其隐式原型指向构造函数的显式原型（obj._proto_ === Object.prototype)

   ```javascript
   console.log(obj._proto_ === Object.Prototype) //true
   console.log(arr._proto_ === Object.Prototype) //true
   console.log(fn._proto_ === Object.Prototype) //true
   ```

5. 当试图得到一个对象的属性时，如果这个对象本身没有这个属性，那么会去它的proto（及构造函数的prototype）中去寻找

   ```javascript
   //构造函数
   function Fn(name) {
     this.name = name;
   }
   //显式原型
   Fn.prototype.alerttName = function() {
     console.log(this.name)
   }
   //创建实例
   var f = new Fn('张三')
   f.printName = function() {
     console.log(this.name)
   }
   f.printName()   //张三
   f.alertName()   //张三
   ```

   #### 设计模式

   ##### 工厂模式

   在函数内创建一个对象，给对象赋予属性及方法再将对象返回

   ```javascript
   function Person() {
     var info = new Object()
     info.name = '张三'
     info.age = 18
     info.sex = function() {
       return 'boy'
     }
     return info
   }
   let p1 = Person()
   console.log(p1.name)  //'张三'
   
   ```

   